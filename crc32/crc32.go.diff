--- a/src/hash/crc32/crc32.go
+++ b/src/hash/crc32/crc32.go
@@ -10,6 +10,7 @@
 import (
 	"hash"
 	"sync"
+	"unsafe"
 )
 
 // The size of a CRC-32 checksum in bytes.
@@ -49,6 +50,12 @@
 // IEEETable is the table for the IEEE polynomial.
 var IEEETable = makeTable(IEEE)
 
+// slicing8Table is array of 8 Tables
+type slicing8Table [8]Table
+
+// iEEETable8 is the slicing8Table for IEEE
+var iEEETable8 = makeTable8(IEEE)
+
 // MakeTable returns the Table constructed from the specified polynomial.
 func MakeTable(poly uint32) *Table {
 	switch poly {
@@ -74,6 +81,20 @@
 			}
 		}
 		t[i] = crc
+	}
+	return t
+}
+
+// makeTable8 returns slicing8Table constructed from the specified polynomial.
+func makeTable8(poly uint32) *slicing8Table {
+	t := new(slicing8Table)
+	t[0] = *makeTable(poly)
+	for i := 0; i < 256; i++ {
+		crc := t[0][i]
+		for j := 1; j < 8; j++ {
+			crc = t[0][crc&0xFF] ^ (crc >> 8)
+			t[j][i] = crc
+		}
 	}
 	return t
 }
@@ -106,10 +127,47 @@
 	return ^crc
 }
 
+var isLittleEndian = testLittleEndian()
+
+func testLittleEndian() bool {
+	v := uintptr(1)
+	bytes := (*[4]byte)(unsafe.Pointer(&v))
+	return bytes[0] == 1
+}
+
+// updateSlicingBy8 updates CRC using Slicing-by-8
+func updateSlicingBy8(crc uint32, tab *slicing8Table, p []byte) uint32 {
+	ptr := uintptr(unsafe.Pointer(&p[0]))
+	// check align by 8 bytes
+	if ptr&7 > 0 {
+		n := 8 - (ptr & 7)
+		crc = update(crc, &tab[0], p[:n])
+		p = p[n:]
+	}
+
+	crc = ^crc
+	n := len(p) / 8
+	pp := (*[1 << 30]uint64)(unsafe.Pointer(&p[0]))[:n]
+	for _, v := range pp {
+		crc ^= uint32(v & 0xFFFFFFFF)
+		next := uint32(v >> 32)
+		crc = tab[0][next>>24] ^ tab[1][(next>>16)&0xFF] ^
+			tab[2][(next>>8)&0xFF] ^ tab[3][next&0xFF] ^
+			tab[4][crc>>24] ^ tab[5][(crc>>16)&0xFF] ^
+			tab[6][(crc>>8)&0xFF] ^ tab[7][crc&0xFF]
+	}
+
+	crc = ^crc
+	return update(crc, &tab[0], p[n*8:])
+}
+
 // Update returns the result of adding the bytes in p to the crc.
 func Update(crc uint32, tab *Table, p []byte) uint32 {
 	if tab == castagnoliTable {
 		return updateCastagnoli(crc, p)
+	}
+	if tab == IEEETable && isLittleEndian && len(p) > 64 {
+		return updateSlicingBy8(crc, iEEETable8, p)
 	}
 	return update(crc, tab, p)
 }
@@ -132,4 +190,4 @@
 
 // ChecksumIEEE returns the CRC-32 checksum of data
 // using the IEEE polynomial.
-func ChecksumIEEE(data []byte) uint32 { return update(0, IEEETable, data) }
+func ChecksumIEEE(data []byte) uint32 { return Update(0, IEEETable, data) }
